root = statement* expression? ;



statement = functionDeclaration
          | letDeclaration
          | assignmentStatement
          | expressionStatement ';'
          | flowControlStatement
          ;

expressionStatement = callExpression
                    | returnExpression
                    | breakExpression
                    | continueExpression
                    ;

flowControlStatement = blockExpression
                     | ifExpression
                     | loopExpression
                     ;



functionDeclaration = 'func' NAME '(' parameterList ')' functionBody ;

functionBody = blockExpression
             | '=>' expression ';'
             ;

letDeclaration = 'let' 'mut'? NAME '=' expression ';' ;

parameter = 'mut'? NAME ;

parameterList = (parameter (',' parameter)*)? ;

assignmentStatement = lValue assignmentOperator expression ';' ;

lValue = identifierExpression | accessExpression ;



expression = blockExpression
           | callExpression
           | lambdaExpression
           | tupleExpression
           | objectExpression
           | parenthesizedExpression
           | ifExpression
           | loopExpression
           | returnExpression
           | breakExpression
           | continueExpression
           | unaryExpression
           | binaryExpression
           | accessExpression
           | identifierExpression
           | stringExpression
           | boolExpression
           | numberExpression
           | nilExpression
           ;

blockExpression = '{' statement* expression? '}' ;

callExpression = expression '(' (expression (',' expression)*)? ')' ;

lambdaExpression = '(' parameterList ')' '=>' expression ;

tupleExpression = '(' expression ',' expression (',' expression)* ')' ;

objectExpression = 'dyn'? '{' (field (',' field)* ','?)? '}' ;

parenthesizedExpression = '(' expression ')' ;

ifExpression = 'if' expression blockExpression 'else' blockExpression ;

loopExpression = 'loop' blockExpression ;

returnExpression = 'return' expression? ;

breakExpression = 'break' expression? ;

continueExpression = 'continue' ;

unaryExpression = unaryOperator expression ;

binaryExpression = expression binaryOperator expression ;

accessExpression = expression '.' fieldName ;

identifierExpression = NAME ;

stringExpression = normalString | interpolatedString ;

boolExpression = 'true' | 'false' ;

numberExpression = NUMBER_LITERAL ;

nilExpression = '(' ')' ;



field = 'mut'? fieldName? ':' expression ;

fieldName = NAME
          | stringExpression
          | '(' expression ')'
          ;



normalString = '"' (STRING_TEXT | '\{' expression '}')* '"' ;

interpolatedString = '\"' (STRING_TEXT | '{' expression '}')* '"' ;



assignmentOperator = '='
                   | '+='
                   | '-='
                   | '*='
                   | '/='
                   ;

unaryOperator = '+'
              | '-'
              | 'not'
              ;

binaryOperator = '+'
               | '-'
               | '*'
               | '/'
               | '<'
               | '>'
               | '<='
               | '>='
               | '=='
               | '!='
               | 'or'
               | 'and'
               ;
