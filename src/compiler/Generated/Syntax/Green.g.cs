// <auto-generated/>

#nullable enable
#pragma warning disable CS0108

namespace Noa.Compiler.Syntax.Green;

internal sealed partial class RootSyntax : SyntaxNode
{
    public required SyntaxList<StatementSyntax> Statements { get; init; }

    public required ExpressionSyntax TrailingExpression { get; init; }

    public override int GetWidth() => Statements.GetWidth() + TrailingExpression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.RootSyntax(this, position, parent);
}

internal abstract partial class StatementSyntax : SyntaxNode
{
}

internal abstract partial class DeclarationSyntax : StatementSyntax
{
}

internal sealed partial class FunctionDeclarationSyntax : DeclarationSyntax
{
    public required Token Func { get; init; }

    public required Token Name { get; init; }

    public required ParameterListSyntax Parameters { get; init; }

    public required FunctionBodySyntax Body { get; init; }

    public override int GetWidth() => Func.GetWidth() + Name.GetWidth() + Parameters.GetWidth() + Body.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.FunctionDeclarationSyntax(this, position, parent);
}

internal sealed partial class ParameterListSyntax : SyntaxNode
{
    public required Token OpenParen { get; init; }

    public required SeparatedSyntaxList<ParameterSyntax> Parameters { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => OpenParen.GetWidth() + Parameters.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ParameterListSyntax(this, position, parent);
}

internal sealed partial class ParameterSyntax : SyntaxNode
{
    public required Token? Mut { get; init; }

    public required Token Name { get; init; }

    public override int GetWidth() => Mut?.GetWidth() ?? 0 + Name.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ParameterSyntax(this, position, parent);
}

internal abstract partial class FunctionBodySyntax : SyntaxNode
{
}

internal sealed partial class BlockBodySyntax : FunctionBodySyntax
{
    public required BlockExpressionSyntax Block { get; init; }

    public override int GetWidth() => Block.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BlockBodySyntax(this, position, parent);
}

internal sealed partial class ExpressionBodySyntax : FunctionBodySyntax
{
    public required Token Arrow { get; init; }

    public required ExpressionSyntax Expression { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => Arrow.GetWidth() + Expression.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ExpressionBodySyntax(this, position, parent);
}

internal sealed partial class LetDeclarationSyntax : SyntaxNode
{
    public required Token Let { get; init; }

    public required Token? Mut { get; init; }

    public required Token Name { get; init; }

    public required Token Equals { get; init; }

    public required ExpressionSyntax Value { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => Let.GetWidth() + Mut?.GetWidth() ?? 0 + Name.GetWidth() + Equals.GetWidth() + Value.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.LetDeclarationSyntax(this, position, parent);
}

internal sealed partial class AssignmentStatementSyntax : StatementSyntax
{
    public required Token Identifier { get; init; }

    public required Token Operator { get; init; }

    public required ExpressionSyntax Value { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => Identifier.GetWidth() + Operator.GetWidth() + Value.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.AssignmentStatementSyntax(this, position, parent);
}

internal sealed partial class FlowControlStatement : SyntaxNode
{
    public required ExpressionSyntax Expression { get; init; }

    public override int GetWidth() => Expression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.FlowControlStatement(this, position, parent);
}

internal sealed partial class ExpressionStatementSyntax : StatementSyntax
{
    public required ExpressionSyntax Expression { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => Expression.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ExpressionStatementSyntax(this, position, parent);
}

internal abstract partial class ExpressionSyntax : SyntaxNode
{
}

internal sealed partial class BlockExpressionSyntax : ExpressionSyntax
{
    public required Token OpenBrace { get; init; }

    public required SyntaxList<StatementSyntax> Statements { get; init; }

    public required ExpressionSyntax TrailingExpression { get; init; }

    public required Token CloseBrace { get; init; }

    public override int GetWidth() => OpenBrace.GetWidth() + Statements.GetWidth() + TrailingExpression.GetWidth() + CloseBrace.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BlockExpressionSyntax(this, position, parent);
}

internal sealed partial class CallExpressionSyntax : ExpressionSyntax
{
    public required ExpressionSyntax Target { get; init; }

    public required Token OpenParen { get; init; }

    public required SeparatedSyntaxList<ExpressionSyntax> Arguments { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => Target.GetWidth() + OpenParen.GetWidth() + Arguments.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.CallExpressionSyntax(this, position, parent);
}

internal sealed partial class LambdaExpressionSyntax : ExpressionSyntax
{
    public required ParameterListSyntax Parameters { get; init; }

    public required Token Arrow { get; init; }

    public required ExpressionSyntax Expression { get; init; }

    public override int GetWidth() => Parameters.GetWidth() + Arrow.GetWidth() + Expression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.LambdaExpressionSyntax(this, position, parent);
}

internal sealed partial class TupleExpressionSyntax : ExpressionSyntax
{
    public required Token OpenParen { get; init; }

    public required SeparatedSyntaxList<ExpressionSyntax> Expressions { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => OpenParen.GetWidth() + Expressions.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.TupleExpressionSyntax(this, position, parent);
}

internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
{
    public required ExpressionSyntax Expression { get; init; }

    public override int GetWidth() => Expression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ParenthesizedExpressionSyntax(this, position, parent);
}

internal sealed partial class IfExpressionSyntax : ExpressionSyntax
{
    public required Token If { get; init; }

    public required Token OpenParen { get; init; }

    public required ExpressionSyntax Condition { get; init; }

    public required Token CloseParen { get; init; }

    public required BlockExpressionSyntax Body { get; init; }

    public required ElseClauseSyntax Else { get; init; }

    public override int GetWidth() => If.GetWidth() + OpenParen.GetWidth() + Condition.GetWidth() + CloseParen.GetWidth() + Body.GetWidth() + Else.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.IfExpressionSyntax(this, position, parent);
}

internal sealed partial class ElseClauseSyntax : SyntaxNode
{
    public required Token Else { get; init; }

    public required BlockExpressionSyntax Body { get; init; }

    public override int GetWidth() => Else.GetWidth() + Body.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ElseClauseSyntax(this, position, parent);
}

internal sealed partial class LoopExpression : ExpressionSyntax
{
    public required Token Loop { get; init; }

    public required BlockExpressionSyntax Body { get; init; }

    public override int GetWidth() => Loop.GetWidth() + Body.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.LoopExpression(this, position, parent);
}

internal sealed partial class ReturnExpressionSyntax : ExpressionSyntax
{
    public required Token Return { get; init; }

    public required ExpressionSyntax? Value { get; init; }

    public override int GetWidth() => Return.GetWidth() + Value?.GetWidth() ?? 0;

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ReturnExpressionSyntax(this, position, parent);
}

internal sealed partial class BreakExpressionSyntax : ExpressionSyntax
{
    public required Token Break { get; init; }

    public required ExpressionSyntax? Value { get; init; }

    public override int GetWidth() => Break.GetWidth() + Value?.GetWidth() ?? 0;

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BreakExpressionSyntax(this, position, parent);
}

internal sealed partial class ContinueExpressionSyntax : ExpressionSyntax
{
    public required Token Continue { get; init; }

    public override int GetWidth() => Continue.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ContinueExpressionSyntax(this, position, parent);
}

internal sealed partial class UnaryExpressionSyntax : ExpressionSyntax
{
    public required Token Operator { get; init; }

    public required ExpressionSyntax Operand { get; init; }

    public override int GetWidth() => Operator.GetWidth() + Operand.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.UnaryExpressionSyntax(this, position, parent);
}

internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
{
    public required ExpressionSyntax Left { get; init; }

    public required Token Operator { get; init; }

    public required ExpressionSyntax Right { get; init; }

    public override int GetWidth() => Left.GetWidth() + Operator.GetWidth() + Right.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BinaryExpressionSyntax(this, position, parent);
}

internal sealed partial class IdentifierExpressionSyntax : ExpressionSyntax
{
    public required Token Identifier { get; init; }

    public override int GetWidth() => Identifier.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.IdentifierExpressionSyntax(this, position, parent);
}

internal sealed partial class StringExpressionSyntax : ExpressionSyntax
{
    public required Token OpenQuote { get; init; }

    public required SyntaxList<StringPart> Parts { get; init; }

    public required Token CloseQuote { get; init; }

    public override int GetWidth() => OpenQuote.GetWidth() + Parts.GetWidth() + CloseQuote.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.StringExpressionSyntax(this, position, parent);
}

internal abstract partial class StringPart : SyntaxNode
{
}

internal sealed partial class TextStringPart : StringPart
{
    public required Token Text { get; init; }

    public override int GetWidth() => Text.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.TextStringPart(this, position, parent);
}

internal sealed partial class InterpolationStringPart : StringPart
{
    public required Token OpenDelimiter { get; init; }

    public required ExpressionSyntax Expression { get; init; }

    public required Token CloseDelimiter { get; init; }

    public override int GetWidth() => OpenDelimiter.GetWidth() + Expression.GetWidth() + CloseDelimiter.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.InterpolationStringPart(this, position, parent);
}

internal sealed partial class BoolExpressionSyntax : ExpressionSyntax
{
    public required Token Value { get; init; }

    public override int GetWidth() => Value.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BoolExpressionSyntax(this, position, parent);
}

internal sealed partial class NumberExpressionSyntax : ExpressionSyntax
{
    public required Token Value { get; init; }

    public override int GetWidth() => Value.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.NumberExpressionSyntax(this, position, parent);
}

internal sealed partial class NilExpressionSyntax : ExpressionSyntax
{
    public required Token OpenParen { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => OpenParen.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.NilExpressionSyntax(this, position, parent);
}
