// <auto-generated/>

#nullable enable
#pragma warning disable CS0108

namespace Noa.Compiler.Syntax.Green;

internal sealed class RootSyntax : SyntaxNode
{
    private int? width;

    public required SyntaxList<StatementSyntax> Statements { get; init; }

    public required ExpressionSyntax TrailingExpression { get; init; }

    public required Token EndOfFile { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Statements.GetWidth() + TrailingExpression.GetWidth() + EndOfFile.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.RootSyntax(this, position, parent);
}

internal abstract class StatementSyntax : SyntaxNode
{
}

internal abstract class DeclarationSyntax : StatementSyntax
{
}

internal sealed class FunctionDeclarationSyntax : DeclarationSyntax
{
    private int? width;

    public required Token Func { get; init; }

    public required Token Name { get; init; }

    public required ParameterListSyntax Parameters { get; init; }

    public required FunctionBodySyntax Body { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Func.GetWidth() + Name.GetWidth() + Parameters.GetWidth() + Body.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.FunctionDeclarationSyntax(this, position, parent);
}

internal sealed class ParameterListSyntax : SyntaxNode
{
    private int? width;

    public required Token OpenParen { get; init; }

    public required SeparatedSyntaxList<ParameterSyntax> Parameters { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => OpenParen.GetWidth() + Parameters.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ParameterListSyntax(this, position, parent);
}

internal sealed class ParameterSyntax : SyntaxNode
{
    private int? width;

    public required Token? Mut { get; init; }

    public required Token Name { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Mut?.GetWidth() ?? 0 + Name.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ParameterSyntax(this, position, parent);
}

internal abstract class FunctionBodySyntax : SyntaxNode
{
}

internal sealed class BlockBodySyntax : FunctionBodySyntax
{
    private int? width;

    public required BlockExpressionSyntax Block { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Block.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BlockBodySyntax(this, position, parent);
}

internal sealed class ExpressionBodySyntax : FunctionBodySyntax
{
    private int? width;

    public required Token Arrow { get; init; }

    public required ExpressionSyntax Expression { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Arrow.GetWidth() + Expression.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ExpressionBodySyntax(this, position, parent);
}

internal sealed class LetDeclarationSyntax : SyntaxNode
{
    private int? width;

    public required Token Let { get; init; }

    public required Token? Mut { get; init; }

    public required Token Name { get; init; }

    public required Token Equals { get; init; }

    public required ExpressionSyntax Value { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Let.GetWidth() + Mut?.GetWidth() ?? 0 + Name.GetWidth() + Equals.GetWidth() + Value.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.LetDeclarationSyntax(this, position, parent);
}

internal sealed class AssignmentStatementSyntax : StatementSyntax
{
    private int? width;

    public required Token Identifier { get; init; }

    public required Token Operator { get; init; }

    public required ExpressionSyntax Value { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Identifier.GetWidth() + Operator.GetWidth() + Value.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.AssignmentStatementSyntax(this, position, parent);
}

internal sealed class FlowControlStatement : SyntaxNode
{
    private int? width;

    public required ExpressionSyntax Expression { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Expression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.FlowControlStatement(this, position, parent);
}

internal sealed class ExpressionStatementSyntax : StatementSyntax
{
    private int? width;

    public required ExpressionSyntax Expression { get; init; }

    public required Token Semicolon { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Expression.GetWidth() + Semicolon.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ExpressionStatementSyntax(this, position, parent);
}

internal abstract class ExpressionSyntax : SyntaxNode
{
}

internal sealed class BlockExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token OpenBrace { get; init; }

    public required SyntaxList<StatementSyntax> Statements { get; init; }

    public required ExpressionSyntax TrailingExpression { get; init; }

    public required Token CloseBrace { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => OpenBrace.GetWidth() + Statements.GetWidth() + TrailingExpression.GetWidth() + CloseBrace.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BlockExpressionSyntax(this, position, parent);
}

internal sealed class CallExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required ExpressionSyntax Target { get; init; }

    public required Token OpenParen { get; init; }

    public required SeparatedSyntaxList<ExpressionSyntax> Arguments { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Target.GetWidth() + OpenParen.GetWidth() + Arguments.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.CallExpressionSyntax(this, position, parent);
}

internal sealed class LambdaExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required ParameterListSyntax Parameters { get; init; }

    public required Token Arrow { get; init; }

    public required ExpressionSyntax Expression { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Parameters.GetWidth() + Arrow.GetWidth() + Expression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.LambdaExpressionSyntax(this, position, parent);
}

internal sealed class TupleExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token OpenParen { get; init; }

    public required SeparatedSyntaxList<ExpressionSyntax> Expressions { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => OpenParen.GetWidth() + Expressions.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.TupleExpressionSyntax(this, position, parent);
}

internal sealed class ParenthesizedExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required ExpressionSyntax Expression { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Expression.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ParenthesizedExpressionSyntax(this, position, parent);
}

internal sealed class IfExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token If { get; init; }

    public required Token OpenParen { get; init; }

    public required ExpressionSyntax Condition { get; init; }

    public required Token CloseParen { get; init; }

    public required BlockExpressionSyntax Body { get; init; }

    public required ElseClauseSyntax Else { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => If.GetWidth() + OpenParen.GetWidth() + Condition.GetWidth() + CloseParen.GetWidth() + Body.GetWidth() + Else.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.IfExpressionSyntax(this, position, parent);
}

internal sealed class ElseClauseSyntax : SyntaxNode
{
    private int? width;

    public required Token Else { get; init; }

    public required BlockExpressionSyntax Body { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Else.GetWidth() + Body.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ElseClauseSyntax(this, position, parent);
}

internal sealed class LoopExpression : ExpressionSyntax
{
    private int? width;

    public required Token Loop { get; init; }

    public required BlockExpressionSyntax Body { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Loop.GetWidth() + Body.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.LoopExpression(this, position, parent);
}

internal sealed class ReturnExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Return { get; init; }

    public required ExpressionSyntax? Value { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Return.GetWidth() + Value?.GetWidth() ?? 0;

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ReturnExpressionSyntax(this, position, parent);
}

internal sealed class BreakExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Break { get; init; }

    public required ExpressionSyntax? Value { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Break.GetWidth() + Value?.GetWidth() ?? 0;

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BreakExpressionSyntax(this, position, parent);
}

internal sealed class ContinueExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Continue { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Continue.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.ContinueExpressionSyntax(this, position, parent);
}

internal sealed class UnaryExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Operator { get; init; }

    public required ExpressionSyntax Operand { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Operator.GetWidth() + Operand.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.UnaryExpressionSyntax(this, position, parent);
}

internal sealed class BinaryExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required ExpressionSyntax Left { get; init; }

    public required Token Operator { get; init; }

    public required ExpressionSyntax Right { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Left.GetWidth() + Operator.GetWidth() + Right.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BinaryExpressionSyntax(this, position, parent);
}

internal sealed class IdentifierExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Identifier { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Identifier.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.IdentifierExpressionSyntax(this, position, parent);
}

internal sealed class StringExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token OpenQuote { get; init; }

    public required SyntaxList<StringPart> Parts { get; init; }

    public required Token CloseQuote { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => OpenQuote.GetWidth() + Parts.GetWidth() + CloseQuote.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.StringExpressionSyntax(this, position, parent);
}

internal abstract class StringPart : SyntaxNode
{
}

internal sealed class TextStringPart : StringPart
{
    private int? width;

    public required Token Text { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Text.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.TextStringPart(this, position, parent);
}

internal sealed class InterpolationStringPart : StringPart
{
    private int? width;

    public required Token OpenDelimiter { get; init; }

    public required ExpressionSyntax Expression { get; init; }

    public required Token CloseDelimiter { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => OpenDelimiter.GetWidth() + Expression.GetWidth() + CloseDelimiter.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.InterpolationStringPart(this, position, parent);
}

internal sealed class BoolExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Value { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Value.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.BoolExpressionSyntax(this, position, parent);
}

internal sealed class NumberExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token Value { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => Value.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.NumberExpressionSyntax(this, position, parent);
}

internal sealed class NilExpressionSyntax : ExpressionSyntax
{
    private int? width;

    public required Token OpenParen { get; init; }

    public required Token CloseParen { get; init; }

    public override int GetWidth() => width ??= ComputeWidth();

    private int ComputeWidth() => OpenParen.GetWidth() + CloseParen.GetWidth();

    public override Syntax.SyntaxNode ToRed(int position, Syntax.SyntaxNode parent) =>
        new Syntax.NilExpressionSyntax(this, position, parent);
}
