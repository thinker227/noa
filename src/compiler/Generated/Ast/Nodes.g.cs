// <auto-generated/>

#nullable enable

namespace Noa.Compiler.Nodes;

public sealed partial class Block(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
    public required ImmutableArray<Statement> Statements { get; init; }

    public required Expression? TrailingExpression { get; init; }

    public override IEnumerable<Node> Children => [..Statements, ..EmptyIfNull(TrailingExpression)];
}

public sealed partial class Root(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
    public required Block Block { get; init; }

    public override IEnumerable<Node> Children => [Block];
}

public sealed partial class Identifier(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
    public required string Name { get; init; }

    public override IEnumerable<Node> Children => [];
}

public abstract partial class Statement(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
}

public sealed partial class Parameter(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
    public required bool IsMutable { get; init; }

    public required Identifier Identifier { get; init; }

    public override IEnumerable<Node> Children => [Identifier];
}

public abstract partial class Declaration(Ast ast, Syntax.SyntaxNode syntax) : Statement(ast, syntax)
{
}

public sealed partial class FunctionDeclaration(Ast ast, Syntax.SyntaxNode syntax) : Declaration(ast, syntax)
{
    public required Identifier Identifier { get; init; }

    public required ImmutableArray<Parameter> Parameters { get; init; }

    public required Expression? ExpressionBody { get; init; }

    public required BlockExpression? BlockBody { get; init; }

    public override IEnumerable<Node> Children => [Identifier, ..Parameters, ..EmptyIfNull(ExpressionBody), ..EmptyIfNull(BlockBody)];
}

public sealed partial class LetDeclaration(Ast ast, Syntax.SyntaxNode syntax) : Declaration(ast, syntax)
{
    public required bool IsMutable { get; init; }

    public required Identifier Identifier { get; init; }

    public required Expression Expression { get; init; }

    public override IEnumerable<Node> Children => [Identifier, Expression];
}

public sealed partial class AssignmentStatement(Ast ast, Syntax.SyntaxNode syntax) : Statement(ast, syntax)
{
    public required Expression Target { get; init; }

    public required AssignmentKind Kind { get; init; }

    public required Expression Value { get; init; }

    public override IEnumerable<Node> Children => [Target, Value];
}

public sealed partial class ExpressionStatement(Ast ast, Syntax.SyntaxNode syntax) : Statement(ast, syntax)
{
    public required Expression Expression { get; init; }

    public override IEnumerable<Node> Children => [Expression];
}

public abstract partial class Expression(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
}

public sealed partial class ErrorExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public override IEnumerable<Node> Children => [];
}

public sealed partial class BlockExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Block Block { get; init; }

    public override IEnumerable<Node> Children => [Block];
}

public sealed partial class CallExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Expression Target { get; init; }

    public required ImmutableArray<Expression> Arguments { get; init; }

    public override IEnumerable<Node> Children => [Target, ..Arguments];
}

public sealed partial class LambdaExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required ImmutableArray<Parameter> Parameters { get; init; }

    public required Expression Body { get; init; }

    public override IEnumerable<Node> Children => [..Parameters, Body];
}

public sealed partial class TupleExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required ImmutableArray<Expression> Expressions { get; init; }

    public override IEnumerable<Node> Children => [..Expressions];
}

public sealed partial class ObjectExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required bool IsDynamic { get; init; }

    public required ImmutableArray<Field> Fields { get; init; }

    public override IEnumerable<Node> Children => [..Fields];
}

public sealed partial class Field(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
    public required bool IsMutable { get; init; }

    public required FieldName? Name { get; init; }

    public override IEnumerable<Node> Children => [..EmptyIfNull(Name)];
}

public abstract partial class FieldName(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
}

public sealed partial class SimpleFieldName(Ast ast, Syntax.SyntaxNode syntax) : FieldName(ast, syntax)
{
    public required string Name { get; init; }

    public override IEnumerable<Node> Children => [];
}

public sealed partial class StringFieldName(Ast ast, Syntax.SyntaxNode syntax) : FieldName(ast, syntax)
{
    public required StringExpression String { get; init; }

    public override IEnumerable<Node> Children => [String];
}

public sealed partial class ExpressionFieldName(Ast ast, Syntax.SyntaxNode syntax) : FieldName(ast, syntax)
{
    public required Expression Expression { get; init; }

    public override IEnumerable<Node> Children => [Expression];
}

public sealed partial class IfExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Expression Condition { get; init; }

    public required BlockExpression IfTrue { get; init; }

    public required ElseClause? Else { get; init; }

    public override IEnumerable<Node> Children => [Condition, IfTrue, ..EmptyIfNull(Else)];
}

public sealed partial class ElseClause(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
    public required BlockExpression IfFalse { get; init; }

    public override IEnumerable<Node> Children => [IfFalse];
}

public sealed partial class LoopExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required BlockExpression Block { get; init; }

    public override IEnumerable<Node> Children => [Block];
}

public sealed partial class ReturnExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Expression? Expression { get; init; }

    public override IEnumerable<Node> Children => [..EmptyIfNull(Expression)];
}

public sealed partial class BreakExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Expression? Expression { get; init; }

    public override IEnumerable<Node> Children => [..EmptyIfNull(Expression)];
}

public sealed partial class ContinueExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public override IEnumerable<Node> Children => [];
}

public sealed partial class UnaryExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required UnaryKind Kind { get; init; }

    public required Expression Operand { get; init; }

    public override IEnumerable<Node> Children => [Operand];
}

public sealed partial class BinaryExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Expression Left { get; init; }

    public required BinaryKind Kind { get; init; }

    public required Expression Right { get; init; }

    public override IEnumerable<Node> Children => [Left, Right];
}

public sealed partial class AccessExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required Expression Target { get; init; }

    public required FieldName Name { get; init; }

    public override IEnumerable<Node> Children => [Target, Name];
}

public sealed partial class IdentifierExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required string Identifier { get; init; }

    public override IEnumerable<Node> Children => [];
}

public sealed partial class StringExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required ImmutableArray<StringPart> Parts { get; init; }

    public override IEnumerable<Node> Children => [..Parts];
}

public abstract partial class StringPart(Ast ast, Syntax.SyntaxNode syntax) : Node(ast, syntax)
{
}

public sealed partial class TextStringPart(Ast ast, Syntax.SyntaxNode syntax) : StringPart(ast, syntax)
{
    public required string Text { get; init; }

    public override IEnumerable<Node> Children => [];
}

public sealed partial class InterpolationStringPart(Ast ast, Syntax.SyntaxNode syntax) : StringPart(ast, syntax)
{
    public required Expression Expression { get; init; }

    public override IEnumerable<Node> Children => [Expression];
}

public sealed partial class BoolExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required bool Value { get; init; }

    public override IEnumerable<Node> Children => [];
}

public sealed partial class NumberExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public required double Value { get; init; }

    public override IEnumerable<Node> Children => [];
}

public sealed partial class NilExpression(Ast ast, Syntax.SyntaxNode syntax) : Expression(ast, syntax)
{
    public override IEnumerable<Node> Children => [];
}
