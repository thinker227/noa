{{- func type -}}
    {{- if $0.list_kind == "Simple" -}}
        SyntaxList<{{ $0.type }}>
    {{- else if $0.list_kind == "Separated" -}}
        SeparatedSyntaxList<{{ $0.type }}>
    {{- else -}}
        {{- $0.type -}}
    {{- end -}}
    {{- if $0.is_optional -}}?{{- end -}}
{{- end -}}

{{- func pos -}}
    position{{ for $m in array.limit $0.members $1 }} + ((Green.{{ $0.name }})green).{{ $m.name }}{{ if $m.is_optional }}?{{ end }}.GetWidth(){{ if $m.is_optional }} ?? 0{{ end }}{{ end -}}
{{- end -}}

// <auto-generated/>

#nullable enable
#pragma warning disable CS0108

namespace Noa.Compiler.Syntax;

{{~ for node in nodes ~}}
public {{ if node.is_abstract }}abstract {{ else if node.children.size == 0 }}sealed {{ end }}partial class {{ node.name }} : {{ node.parent.name }}
{
    {{~ if !node.is_abstract ~}}
    {{~ for member in node.non_inherited_members ~}}
    public {{ type member }} {{ member.name }} => ({{ type member }})((Green.{{ node.name }})green).{{ member.name }}{{ if member.is_optional }}?{{ end }}.ToRed{{ if member.is_list }}<Green.{{ member.type }}, {{ member.type }}>{{ end }}({{ pos node for.index }}, this);
    {{~ if !for.last ~}}

    {{~ end ~}}
    {{~ end ~}}
    
    {{~ end ~}}
    internal {{ node.name }}(Green.{{ node.name }} green, int position, SyntaxNode parent) : base(green, position, parent) {}
}
{{~ if !for.last ~}}

{{~ end ~}}
{{~ end ~}}
