{{- func type -}}
    {{- if $0.list_kind == "Simple" -}}
        SyntaxList<{{ $0.type }}>
    {{- else if $0.list_kind == "Separated" -}}
        SeparatedSyntaxList<{{ $0.type }}>
    {{- else -}}
        {{- $0.type -}}
    {{- end -}}
    {{- if $0.is_optional -}}?{{- end -}}
{{- end -}}

{{- func pos -}}
    FullPosition{{ for $m in array.limit $0.members $1 }} + {{ if !$m.is_optional }}green.{{ $m.name }}.GetFullWidth(){{ else }}(green.{{ $m.name }}?.GetFullWidth() ?? 0){{ end }}{{ end -}}
{{- end -}}

// <auto-generated/>

#nullable enable
#pragma warning disable CS0108

using System.Diagnostics;

namespace Noa.Compiler.Syntax;

{{~ for node in nodes ~}}
public {{ if node.is_abstract }}abstract {{ else if node.children.size == 0 }}sealed {{ end }}class {{ node.name }} : {{ node.parent.name }}
{
    {{~ if !node.is_abstract ~}}
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private readonly Green.{{ node.name }} green;

    internal override Green.SyntaxNode Green => green;

    {{~ for member in node.non_inherited_members ~}}
    public {{ type member }} {{ member.name }} => ({{ type member }})green.{{ member.name }}{{ if member.is_optional }}?{{ end }}.ToRed({{ pos node for.index }}, this);
    
    {{~ end ~}}
    internal {{ node.name }}(Green.{{ node.name }} green, int fullPosition, SyntaxNode parent) : base(fullPosition, parent) =>
        this.green = green;
    
    public override IEnumerable<SyntaxNode> Children
    {
        get
        {
            {{~ for member in node.members ~}}
            {{ if member.is_optional }}if ({{ member.name}} is not null) {{ end }}yield return {{ member.name }};
            {{~ end ~}}
            yield break;
        }
    }
    {{~ else ~}}
    internal {{ node.name }}(int fullPosition, SyntaxNode parent) : base(fullPosition, parent) {}
    {{~ end ~}}
}
{{~ if !for.last ~}}

{{~ end ~}}
{{~ end ~}}
